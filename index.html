<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>暗記アプリ（試作）</title>
  
  <!-- Excel読み込み用ライブラリ (SheetJS) -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

  <style>
    /* --- style.css --- */
    body {
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: #f5f5f5;
      touch-action: none;
    }

    #app {
      display: flex;
      justify-content: center;
      align-items: flex-start; /* 画面の上の方に配置 */
      height: 100vh;
      width: 100vw;
      padding-top: 20px;
      box-sizing: border-box;
    }

    /* カードのデザイン */
    .card {
      background: white;
      width: 85%;
      max-width: 400px;
      /* 高さは自動だが、画面からはみ出さないように制限 */
      height: auto;
      max-height: 80vh; 
      min-height: 200px;
      
      padding: 32px 24px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      cursor: pointer;
      touch-action: none; /* スワイプ操作のためブラウザ標準アクションを無効化 */
      user-select: none;
      
      display: flex;
      flex-direction: column;
      justify-content: flex-start; /* 【修正】垂直方向：上揃え */
      
      position: relative;
      margin-top: 5vh; /* 画面上部からの余白 */
      
      overflow-y: auto; /* 【修正】長文の場合はカード内でスクロール可能に */
    }

    .question {
      font-size: 1.4rem;
      font-weight: bold;
      margin-bottom: 24px;
      
      text-align: left; /* 【修正】左揃え（改行を見やすくするため） */
      line-height: 1.5;
      
      white-space: pre-wrap; /* 【重要】改行コードを反映 */
      word-wrap: break-word; /* 長い単語を折り返す */
    }

    .answer {
      font-size: 1.1rem;
      color: #444;
      border-top: 2px solid #f0f0f0;
      padding-top: 20px;
      
      text-align: left; /* 【修正】左揃え */
      line-height: 1.6;
      
      white-space: pre-wrap; /* 【重要】改行コードを反映 */
      word-wrap: break-word;
    }

    .hidden {
      display: none;
    }

    /* フォルダ選択画面（パスブラウザ）のスタイル */
    .path-browser {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
    }

    .folder-row {
      background: white;
      margin: 4px 0;
      border-bottom: 1px solid #eee;
      transition: background 0.2s;
    }

    .folder-row:active {
      background: #f0f0f0;
    }

    /* --- index.html 内の style --- */
    html, body {
        height: 100%;
        margin: 0;
        overscroll-behavior: none;
        touch-action: none;
    }

    body {
        overflow: hidden;
    }

    /* インポートボタン */
    #import {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.9);
        padding: 6px 10px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        font-size: 0.8rem;
    }
  </style>
</head>
<body>

  <!-- ファイル選択 -->
  <div id="import">
    <span style="font-weight:bold; margin-right:5px;">Excel読込:</span>
    <input type="file" id="tsvInput" accept=".xlsx, .xls" />
  </div>

  <main id="app"></main>

  <script>
    /* =========================================
       Modules Combined for Single File Execution
       ========================================= */

    /* --- card.js --- */
    class Card {
      constructor({ id, path, question, answer, note = "" }) {
        this.id = id           // 内部ID
        this.path = path       // フォルダパス
        this.question = question
        this.answer = answer
        this.note = note       // 備考（Excelの3列目）
      }
    }

    /* --- db.js --- */
    const DB_NAME = "ankiApp"
    const DB_VERSION = 2

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION)

        request.onupgradeneeded = (e) => {
          const db = e.target.result
          
          if (!db.objectStoreNames.contains("cards")) {
            db.createObjectStore("cards", { keyPath: "id" })
          }

          if (!db.objectStoreNames.contains("reviews")) {
            db.createObjectStore("reviews", { 
              keyPath: "id",
              autoIncrement: true 
            })
          }
        }

        request.onsuccess = () => resolve(request.result)
        request.onerror = () => reject(request.error)
      })
    }

    /* --- cardDB.js --- */
    const CARD_STORE_NAME = "cards"

    async function saveCards(cards) {
      const db = await openDB()
      const tx = db.transaction(CARD_STORE_NAME, "readwrite")
      const store = tx.objectStore(CARD_STORE_NAME)

      const promises = cards.map(card => {
        return new Promise((resolve, reject) => {
          const req = store.put(card)
          req.onsuccess = () => resolve()
          req.onerror = () => reject(req.error)
        })
      })

      await Promise.all(promises)
    }

    async function loadCards() {
      const db = await openDB()
      const tx = db.transaction(CARD_STORE_NAME, "readonly")
      const store = tx.objectStore(CARD_STORE_NAME)

      return new Promise((resolve, reject) => {
        const req = store.getAll()
        req.onsuccess = () => resolve(req.result)
        req.onerror = () => reject(req.error)
      })
    }

    /* --- reviewDB.js --- */
    const REVIEW_STORE_NAME = "reviews"

    async function saveReviewToDB(review) {
      const db = await openDB()
      const tx = db.transaction(REVIEW_STORE_NAME, "readwrite")
      const store = tx.objectStore(REVIEW_STORE_NAME)

      return new Promise((resolve, reject) => {
        const req = store.add(review)
        req.onsuccess = () => resolve(req.result)
        req.onerror = () => reject(req.error)
      })
    }

    /* --- pathTree.js --- */
    function buildPathTree(cards) {
      const root = {}

      for (const card of cards) {
        const parts = card.path.split("/")
        let node = root

        for (const part of parts) {
          if (!node[part]) {
            node[part] = {}
          }
          node = node[part]
        }

        if (!node.__cards__) {
          node.__cards__ = []
        }
        node.__cards__.push(card)
      }

      return root
    }

    function collectCards(node) {
      let result = []

      if (node.__cards__) {
        result = result.concat(node.__cards__)
      }

      for (const key of Object.keys(node)) {
        if (key !== "__cards__") {
          result = result.concat(collectCards(node[key]))
        }
      }

      return result
    }

    /* --- xlsxImporter.js --- */
    async function importXLSX(file, path) {
      const data = await file.arrayBuffer()
      const workbook = XLSX.read(data)
      const firstSheetName = workbook.SheetNames[0]
      const worksheet = workbook.Sheets[firstSheetName]
      
      const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1 })
      const dataRows = rows.length > 1 ? rows.slice(1) : []

      const cards = dataRows
        .filter(row => row.length > 0 && row[0])
        .map((row, index) => {
          const question = row[0] ? String(row[0]) : ""
          const answer = row[1] ? String(row[1]) : ""
          const note = row[2] ? String(row[2]) : ""

          return new Card({
            id: `${path}-${index}-${crypto.randomUUID()}`,
            path,
            question,
            answer,
            note
          })
        })

      await saveCards(cards)
      return cards
    }

    /* --- cardView.js --- */
    function createCardView(card, { onSwipe } = {}) {
      const cardEl = document.createElement("div")
      cardEl.className = "card"

      const questionEl = document.createElement("div")
      questionEl.className = "question"
      questionEl.textContent = card.question

      const answerEl = document.createElement("div")
      answerEl.className = "answer hidden"
      answerEl.textContent = card.answer
      
      if (card.note) {
        const noteEl = document.createElement("div")
        noteEl.style.fontSize = "0.8rem"
        noteEl.style.color = "#888"
        noteEl.style.marginTop = "10px"
        noteEl.style.textAlign = "left" // 備考も左寄せ
        noteEl.textContent = card.note
        answerEl.appendChild(noteEl)
      }

      cardEl.append(questionEl, answerEl)

      // タップで解答表示（テキスト選択を阻害しないように判定を入れるとより良いが、簡易実装としてclickを使用）
      cardEl.addEventListener("click", (e) => {
         // カード内のスクロール操作等で誤爆しないように、少し工夫しても良い
         answerEl.classList.toggle("hidden")
      })

      // スワイプ検出
      let startX = null
      let startY = null /* 垂直スクロールと区別するためにYも取得 */

      cardEl.addEventListener("pointerdown", (e) => {
        startX = e.clientX
        startY = e.clientY
        // setPointerCaptureするとスクロールができなくなる場合があるため、
        // 状況によっては外すが、スワイプ判定を優先する場合はつけておく
        cardEl.setPointerCapture(e.pointerId)
      })

      cardEl.addEventListener("pointerup", (e) => {
        if (startX === null) return

        const deltaX = e.clientX - startX
        const deltaY = e.clientY - startY
        const threshold = 80

        // 横方向の移動が大きく、かつ縦方向の移動が小さい場合のみスワイプとみなす
        if (Math.abs(deltaX) > threshold && Math.abs(deltaY) < 50) {
          if (deltaX > 0) {
            onSwipe?.("right")
          } else {
            onSwipe?.("left")
          }
        }

        startX = null
        startY = null
      })

      return cardEl
    }

    /* --- pathBrowser.js --- */
    function createPathBrowser(tree, onSelect) {
      const container = document.createElement("div")
      container.className = "path-browser"

      function renderNode(node, depth = 0) {
        const wrapper = document.createElement("div")

        for (const key of Object.keys(node)) {
          if (key === "__cards__") continue

          const row = document.createElement("div")
          row.className = "folder-row"
          row.textContent = key
          row.style.paddingLeft = `${(depth * 20) + 10}px`
          row.style.paddingTop = "12px"
          row.style.paddingBottom = "12px"
          row.style.cursor = "pointer"
          row.style.userSelect = "none"
          
          const childCards = collectCards(node[key])
          const countSpan = document.createElement("span")
          countSpan.style.float = "right"
          countSpan.style.marginRight = "10px"
          countSpan.style.color = "#999"
          countSpan.style.fontSize = "0.9em"
          countSpan.textContent = `${childCards.length}問`
          row.appendChild(countSpan)

          row.addEventListener("click", () => {
            if (childCards.length === 0) return
            onSelect(childCards)
          })

          wrapper.appendChild(row)
          wrapper.appendChild(renderNode(node[key], depth + 1))
        }

        return wrapper
      }

      const list = renderNode(tree)
      container.appendChild(list)
      
      return container
    }

    /* --- main.js --- */
    document.addEventListener("touchmove", e => {
      // #app直下以外でのスクロールを防止したいが、
      // カード内スクロール(.card)やブラウザ(.path-browser)は許可する必要があるため
      // e.preventDefault() を無条件に呼ぶのはやめる
      // e.preventDefault()
    }, { passive: false })

    const app = document.getElementById("app")

    /* =====================
       永続化
    ===================== */
    async function saveReview(result) {
      await saveReviewToDB(result)
    }

    /* =====================
       描画 
    ===================== */
    function renderCard(card, onNext) {
      app.innerHTML = ""

      const cardView = createCardView(card, {
        onSwipe(direction) {
          const outcome = direction === "left" ? "correct" : "incorrect"

          saveReview({
            cardId: card.id,
            cardPath: card.path,
            outcome,
            reviewedAt: new Date().toISOString()
          })

          onNext()
        }
      })

      app.appendChild(cardView)
    }

    /* =====================
       TSV/XLSX読み込み
    ===================== */
    const tsvInput = document.getElementById("tsvInput")

    tsvInput.addEventListener("change", async e => {
      const file = e.target.files[0]
      if (!file) return

      const path = prompt("この問題群のフォルダ名を入力してください（例: 英語/英単語/Part1）")
      if (!path) {
        tsvInput.value = ""
        return
      }

      try {
        const importedCards = await importXLSX(file, path)
        alert(`${importedCards.length} 問を読み込みました`)
        tsvInput.value = ""
        await showPathSelection()
      } catch (err) {
        console.error(err)
        alert("読み込みに失敗しました")
      }
    })

    /* =====================
       起動時処理
    ===================== */
    async function showPathSelection() {
      const cards = await loadCards()
      app.innerHTML = ""

      if (cards.length === 0) {
        const msg = document.createElement("div")
        msg.textContent = "問題がありません。右上のボタンからExcelファイルをインポートしてください。"
        msg.style.padding = "20px"
        msg.style.textAlign = "center"
        app.appendChild(msg)
        return
      }

      const tree = buildPathTree(cards)

      const browser = createPathBrowser(tree, (selectedCards) => {
        startQuiz(selectedCards)
      })

      app.appendChild(browser)
    }

    /* =====================
       出題開始処理
    ===================== */
    function startQuiz(cards) {
      if (!cards || cards.length === 0) {
        alert("出題できる問題がありません")
        return
      }

      // シャッフル
      const shuffled = [...cards].sort(() => Math.random() - 0.5)
      
      let index = 0

      function show() {
        const card = shuffled[index]
        renderCard(card, () => {
          index = (index + 1) % shuffled.length
          show()
        })
      }

      show()
    }

    showPathSelection()

  </script>
</body>
</html>