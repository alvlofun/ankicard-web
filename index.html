<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>æš—è¨˜ã‚¢ãƒ—ãƒªï¼ˆè©¦ä½œï¼‰</title>
  
  <!-- Excelèª­ã¿è¾¼ã¿ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (SheetJS) -->
  <!-- Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦JSONãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

  <style>
    /* --- style.css --- */
    /* ãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ«: ãƒ¢ãƒã‚¤ãƒ«ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã§ã€ã‚¿ãƒƒãƒæ“ä½œã«æœ€é©åŒ– */
    body {
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: #f5f5f5;
      touch-action: none; /* ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œã®å¹²æ¸‰ã‚’é˜²ã */
    }

    #app {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 100vh;
      width: 100vw;
      padding-top: 20px;
      box-sizing: border-box;
      position: relative;
    }

    /* é‡è¦ï¼šéè¡¨ç¤ºã‚¯ãƒ©ã‚¹ï¼ˆå„ªå…ˆåº¦ã‚’ä¸Šã’ã‚‹ãŸã‚ã« !important ã‚’ä»˜ä¸ï¼‰ */
    /* JSã§ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆã«ä½¿ç”¨ */
    .hidden {
      display: none !important;
    }

    /* --- æˆ»ã‚‹ãƒœã‚¿ãƒ³ --- */
    .back-button-container {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
    }
    .back-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      font-weight: bold;
      color: #333;
    }

    /* --- ã‚«ãƒ¼ãƒ‰ã®ãƒ‡ã‚¶ã‚¤ãƒ³ --- */
    /* ã‚«ãƒ¼ãƒ‰UI: Tinderãƒ©ã‚¤ã‚¯ãªã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œã‚’æƒ³å®šã—ãŸã‚«ãƒ¼ãƒ‰å‹ãƒ‡ã‚¶ã‚¤ãƒ³ */
    .card {
      background: white;
      width: 85%;
      max-width: 400px;
      height: auto;
      max-height: 75vh; 
      min-height: 200px;
      padding: 32px 24px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      cursor: pointer;
      touch-action: none;
      user-select: none;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      position: relative;
      margin-top: 5vh;
      overflow-y: auto; /* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒå¤šã„å ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
    }

    .question {
      font-size: 1.4rem;
      font-weight: bold;
      margin-bottom: 24px;
      text-align: left;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .answer {
      font-size: 1.1rem;
      color: #444;
      border-top: 2px solid #f0f0f0;
      padding-top: 20px;
      text-align: left;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    /* ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º: ç¾åœ¨ã®æ¨å®šç¢ºç‡ã‚„çŠ¶æ…‹ã‚’è¡¨ç¤º */
    .card-stats-debug {
      font-size: 0.75rem;
      color: #aaa;
      margin-bottom: 10px;
      text-align: right;
      font-family: monospace;
    }

    /* --- ãƒ•ã‚©ãƒ«ãƒ€é¸æŠç”»é¢ï¼ˆãƒ‘ã‚¹ãƒ–ãƒ©ã‚¦ã‚¶ï¼‰ --- */
    /* éšå±¤åŒ–ã•ã‚ŒãŸå•é¡Œé›†ã‚’ãƒŠãƒ“ã‚²ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã®UI */
    .path-browser {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      padding: 60px 20px 20px 20px;
      box-sizing: border-box;
      padding-bottom: 80px;
    }

    .folder-row {
      background: white;
      margin: 6px 0;
      border-bottom: 1px solid #eee;
      border-radius: 8px;
      transition: background 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
    }

    .folder-info {
      flex-grow: 1;
      padding: 12px;
      cursor: pointer;
    }

    .folder-row:active {
      background: #f0f0f0;
    }

    /* --- ã‚±ãƒãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆãƒ•ã‚©ãƒ«ãƒ€ã”ã¨ã®æ“ä½œãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼‰ --- */
    .kebab-container {
      position: relative;
      height: 100%;
      display: flex;
      align-items: center;
    }

    .kebab-btn {
      font-size: 1.2rem;
      padding: 10px 15px;
      color: #888;
      cursor: pointer;
      line-height: 1;
    }
    
    .kebab-btn:active {
      background-color: #eee;
      border-radius: 50%;
    }

    .menu-popup {
      position: absolute;
      top: 100%;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 2000;
      min-width: 120px;
      display: none; 
      overflow: hidden;
    }

    .menu-popup.show {
      display: block;
    }

    .menu-item {
      padding: 12px 16px;
      font-size: 0.95rem;
      color: #333;
      cursor: pointer;
      border-bottom: 1px solid #f5f5f5;
    }
    .menu-item:last-child {
      border-bottom: none;
    }
    .menu-item:hover, .menu-item:active {
      background-color: #f7f7f7;
    }

    /* --- å•é¡Œä¸€è¦§ç”»é¢ --- */
    .card-list-view {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      padding: 60px 20px 20px 20px;
      box-sizing: border-box;
      background: white;
    }
    
    .list-header {
      font-weight: bold;
      margin-bottom: 20px;
      font-size: 1.2rem;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }

    .list-item {
      border-bottom: 1px solid #eee;
      padding: 12px 0;
    }
    
    .list-q {
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }
    .list-a {
      color: #666;
      font-size: 0.9rem;
    }
    .list-note {
      color: #999;
      font-size: 0.8rem;
      margin-top: 2px;
    }

    html, body {
        height: 100%;
        margin: 0;
        overscroll-behavior: none;
        touch-action: none;
    }

    body {
        overflow: hidden;
    }

    /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼: è¨­å®šã‚„Excelã‚¤ãƒ³ãƒãƒ¼ãƒˆãªã©ã®æ©Ÿèƒ½ãƒœã‚¿ãƒ³é…ç½® */
    #toolbar {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        display: none; /* JSã§åˆ¶å¾¡ */
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
    }

    .tool-btn {
        background: rgba(255, 255, 255, 0.95);
        padding: 6px 10px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        font-size: 0.8rem;
        cursor: pointer;
        border: 1px solid #ddd;
        display: flex;
        align-items: center;
        justify-content: center;
        white-space: nowrap;
    }

    /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€šã‚¹ã‚¿ã‚¤ãƒ«: è¨­å®šç”»é¢ã‚„MCMCç”»é¢ã§ä½¿ç”¨ */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 3000;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .modal-title {
      font-weight: bold;
      font-size: 1.2rem;
      margin-bottom: 15px;
    }
    .progress-bar {
      width: 100%;
      height: 10px;
      background: #eee;
      border-radius: 5px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-fill {
      height: 100%;
      background: #4caf50;
      width: 0%;
      transition: width 0.1s;
    }
    
    /* MCMCãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ç”»é¢ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    .param-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 8px 0;
      padding: 8px;
      background: #f9f9f9;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    .param-name { font-weight: bold; flex: 1; }
    .param-val { font-family: monospace; text-align: right; margin-right: 10px; }
    .param-rhat { font-family: monospace; font-size: 0.8rem; color: #666; width: 60px; text-align: right; }
    .rhat-bad { color: #d32f2f; font-weight: bold; }
    .changed { color: #d32f2f; font-weight: bold; }
    .improved { color: #2e7d32; font-weight: bold; }

    /* æ‰‹å‹•è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    .config-label {
      display: block;
      margin-bottom: 15px;
      font-weight: bold;
      font-size: 0.95rem;
    }
    .config-label input {
      display: block;
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
    }
    .config-desc {
      font-weight: normal;
      font-size: 0.8rem;
      color: #666;
      margin-top: 3px;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    .btn-primary {
      background: #333; color: white; border: none;
      padding: 8px 16px; border-radius: 4px; cursor: pointer;
    }
    .btn-secondary {
      background: #eee; color: #333; border: none;
      padding: 8px 16px; border-radius: 4px; cursor: pointer;
    }
    .error-msg {
      color: #d32f2f;
      background: #ffebee;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      font-size: 0.9rem;
    }

  </style>
</head>
<body>

  <!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼: ç”»é¢å³ä¸Šã®æ“ä½œãƒœã‚¿ãƒ³ç¾¤ -->
  <div id="toolbar">
    <div class="tool-btn" id="configBtn">
      ğŸ”§ è¨­å®š
    </div>
    <div class="tool-btn" id="mcmcBtn">
      âš™ï¸ MCMC
    </div>
    <div class="tool-btn">
      <span style="font-weight:bold; margin-right:5px;">Excel:</span>
      <input type="file" id="tsvInput" accept=".xlsx, .xls" style="width:170px;" />
    </div>
  </div>

  <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è¡¨ç¤ºé ˜åŸŸ: ã“ã“ã«ã‚«ãƒ¼ãƒ‰ã‚„ãƒ•ã‚©ãƒ«ãƒ€ãƒªã‚¹ãƒˆãŒæç”»ã•ã‚Œã‚‹ -->
  <main id="app"></main>

  <!-- æ‰‹å‹•è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«: å­¦ç¿’ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®é–¾å€¤ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›´ã™ã‚‹ãŸã‚ã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚° -->
  <div id="configModal" class="modal-overlay hidden">
    <div class="modal-content">
      <div class="modal-title">å‡ºé¡Œè¨­å®š</div>
      <div style="margin-bottom:15px; font-size:0.9rem; color:#666; line-height:1.4;">
        å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®šï¼ˆMCMCã§è‡ªå‹•æœ€é©åŒ–æ¨å¥¨ï¼‰<br>
        å¤‰æ›´ã¯æ¬¡å›ã®å‡ºé¡Œåˆ¤å®šã‹ã‚‰å³åº§ã«åæ˜ ã•ã‚Œã¾ã™ã€‚
      </div>
      
      <!-- å­¦ç¿’é€²è¡Œåˆ¶å¾¡ -->
      <div style="font-weight:bold; margin-top:15px; border-bottom:1px solid #eee;">å­¦ç¿’ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡</div>
      <label class="config-label">
        å­¦ç¿’ä¸­ã®åŒæ™‚é€²è¡Œæ•° (Learning Threshold)
        <input type="number" id="cfgLearningThreshold" min="1" max="100">
      </label>
      <label class="config-label">
        æ¨å®šèª¤ç­”æ•°ã®è¨±å®¹ä¸Šé™ (Likely Wrong Limit)
        <input type="number" id="cfgLikelyWrongLimit" min="0" max="50">
      </label>

      <!-- ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆç°¡æ˜“è¡¨ç¤ºï¼‰ -->
      <div style="font-weight:bold; margin-top:15px; border-bottom:1px solid #eee;">ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</div>
      <label class="config-label">
        Î²0 (Base Logit)
        <input type="number" id="cfgBeta0" step="0.1">
      </label>
      <label class="config-label">
        Ï„ (Retention Scale Days)
        <input type="number" id="cfgTau" step="0.1" min="0.1">
      </label>
  
      <div class="modal-actions">
        <button class="btn-secondary" id="configCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button class="btn-primary" id="configSave">ä¿å­˜</button>
      </div>
    </div>
  </div>

  <!-- MCMC ãƒ¢ãƒ¼ãƒ€ãƒ«: éå»ã®å›ç­”å±¥æ­´ã«åŸºã¥ã„ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è‡ªå‹•æœ€é©åŒ–ã™ã‚‹æ©Ÿèƒ½ -->
  <div id="mcmcModal" class="modal-overlay hidden">
    <div class="modal-content">
      <div class="modal-title">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ– (MCMC)</div>
      <div id="mcmcStatus">åˆæœŸåŒ–ä¸­...</div>
      <div class="progress-bar"><div id="mcmcProgress" class="progress-fill"></div></div>
      <div id="mcmcResults"></div>
      <div class="modal-actions" id="mcmcActions" style="display:none;">
        <button class="btn-secondary" id="mcmcCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button class="btn-primary" id="mcmcApply">é©ç”¨ã™ã‚‹</button>
      </div>
      <!-- é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ç”¨ï¼‰ -->
      <div class="modal-actions" id="mcmcErrorActions" style="display:none;">
        <button class="btn-secondary" id="mcmcErrorClose">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>

  <script>
    /* --- 1. å®šæ•°ãƒ»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (LocalStorageå¯¾å¿œ) --- */
    /* ãƒ­ã‚¸ã‚¹ãƒ†ã‚£ãƒƒã‚¯å›å¸°ãƒ™ãƒ¼ã‚¹ã®è¨˜æ†¶ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
       logit(p) = Î²0 + Î²1*logit(p_hist) + Î²2*log(r(t)) + d_path
       r(t) = (1 + t/Ï„)^(-Î³)
       p_hist: é‡ã¿ 1/(k+Î») ã§ã®åŠ é‡å¹³å‡æ­£ç­”ç‡
    */
    const DEFAULT_CONFIG = {
      // ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
      BETA_0: 0.0,
      BETA_1: 1.0,
      BETA_2: 1.0,
      TAU: 1.0,    // æ—¥å˜ä½
      GAMMA: 1.0,
      LAMBDA: 1.0,
      PATH_INTERCEPTS: {}, // pathã”ã¨ã®d_path { "path/to/folder": 0.0, ... }

      // å­¦ç¿’ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ç”¨ã®é–¾å€¤
      EXPLORATION_RATE: 0.1,    // æ¢ç´¢ç‡
      LEARNING_THRESHOLD: 5,           // åŒæ™‚ã«å­¦ç¿’ä¸­çŠ¶æ…‹ã«ãŠã‘ã‚‹ã‚«ãƒ¼ãƒ‰ã®æœ€å¤§æ•°
      LIKELY_WRONG_LIMIT: 5,           // ã€Œé–“é•ãˆãã†ãªã‚«ãƒ¼ãƒ‰ã€ãŒã“ã®æ•°æœªæº€ãªã‚‰æ–°è¦ã‚«ãƒ¼ãƒ‰ã‚’æŠ•å…¥ã™ã‚‹
      MASTER_PROB_THRESHOLD: 0.9,      // ã“ã®ç¢ºç‡ã‚’è¶…ãˆãŸã‚‰ç¿’å¾—å€™è£œã¨ã™ã‚‹
      LEARNING_PROB_THRESHOLD: 0.8,    // ã“ã®ç¢ºç‡ã‚’ä¸‹å›ã£ãŸã‚‰å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã™
      CONSECUTIVE_SUCCESS_REQUIRED: 2  // ç¿’å¾—å€™è£œã«ãªã£ã¦ã‹ã‚‰ã•ã‚‰ã«ä½•å›é€£ç¶šæ­£è§£ã§ã€Œç¿’å¾—æ¸ˆã¿ã€ã«ã™ã‚‹ã‹
    };

    // è¨­å®šã®ãƒ­ãƒ¼ãƒ‰ã¨ã‚µãƒ‹ã‚¿ã‚¤ã‚ºï¼ˆLocalStorageã‹ã‚‰èª­ã¿è¾¼ã¿ï¼‰
    let CONFIG = { ...DEFAULT_CONFIG };
    try {
      const savedConfig = localStorage.getItem("ankiAppConfig");
      if (savedConfig) {
        const parsed = JSON.parse(savedConfig);
        
        // æ–°ã—ã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒãƒ¼ã‚¸ï¼ˆæ•°å€¤å¤‰æ›ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
        if (parsed.BETA_0 !== undefined) parsed.BETA_0 = Number(parsed.BETA_0);
        if (parsed.BETA_1 !== undefined) parsed.BETA_1 = Number(parsed.BETA_1);
        if (parsed.BETA_2 !== undefined) parsed.BETA_2 = Number(parsed.BETA_2);
        if (parsed.TAU) parsed.TAU = Number(parsed.TAU) || 1.0;
        if (parsed.GAMMA) parsed.GAMMA = Number(parsed.GAMMA) || 1.0;
        if (parsed.LAMBDA) parsed.LAMBDA = Number(parsed.LAMBDA) || 1.0;
        // PATH_INTERCEPTS ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã®ã§ãã®ã¾ã¾ï¼ˆå‹ãƒã‚§ãƒƒã‚¯ã¯ç°¡æ˜“çš„ã«ï¼‰
        if (parsed.PATH_INTERCEPTS && typeof parsed.PATH_INTERCEPTS === 'object') {
             // ãã®ã¾ã¾æ¡ç”¨
        } else {
             parsed.PATH_INTERCEPTS = {};
        }

        // æ—§ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ®‹éª¸ãŒæ®‹ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŒã€CONFIGã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ã£ã¦ã‚‚ç„¡å®³
        
        // ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        if (parsed.LEARNING_THRESHOLD) parsed.LEARNING_THRESHOLD = Number(parsed.LEARNING_THRESHOLD) || 5;
        if (parsed.LIKELY_WRONG_LIMIT !== undefined) parsed.LIKELY_WRONG_LIMIT = Number(parsed.LIKELY_WRONG_LIMIT);
        
        CONFIG = { ...CONFIG, ...parsed }; 
        if (typeof CONFIG.LIKELY_WRONG_LIMIT !== 'number') CONFIG.LIKELY_WRONG_LIMIT = DEFAULT_CONFIG.LIKELY_WRONG_LIMIT;
      }
    } catch(e) { console.error("Config load failed", e); }

    function saveConfig() {
      localStorage.setItem("ankiAppConfig", JSON.stringify(CONFIG));
    }

    /* --- 2. ãƒ‡ãƒ¼ã‚¿æ§‹é€  --- */
    // ã‚«ãƒ¼ãƒ‰æƒ…å ±ã‚¯ãƒ©ã‚¹ï¼ˆä¸å¤‰ãªæƒ…å ±ï¼‰
    class Card {
      constructor({ id, path, question, answer, note = "" }) {
        this.id = id;
        this.path = path; // ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹
        this.question = question;
        this.answer = answer;
        this.note = note;
      }
    }

    // ã‚«ãƒ¼ãƒ‰ã”ã¨ã®å­¦ç¿’çŠ¶æ…‹ç®¡ç†ã‚¯ãƒ©ã‚¹ï¼ˆå¯å¤‰ãªæƒ…å ±ï¼‰
    class CardStats {
      constructor(cardId) {
        this.cardId = cardId;
        this.state = "new";           // new, learning, mastered
        this.lastReviewedAt = null;   // æœ€çµ‚å›ç­”æ—¥æ™‚
        this.estimatedP = 0.5;        // æ¨å®šè¨˜æ†¶ç‡ (0.0 - 1.0)
        this.consecutiveHighP = 0;    // é«˜ç¢ºç‡çŠ¶æ…‹ã§ã®é€£ç¶šæ­£è§£æ•°ï¼ˆç¿’å¾—åˆ¤å®šç”¨ï¼‰
      }
    }

    /* --- 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š (IndexedDB) --- */
    const DB_NAME = "ankiApp";
    const DB_VERSION = 3; 

    // IndexedDBã®ã‚ªãƒ¼ãƒ—ãƒ³ã¨ã‚¹ã‚­ãƒ¼ãƒå®šç¾©
    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          const tx = e.target.transaction;

          // ã‚«ãƒ¼ãƒ‰ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ã‚¹ãƒˆã‚¢
          if (!db.objectStoreNames.contains("cards")) {
            db.createObjectStore("cards", { keyPath: "id" });
          }
          
          // å›ç­”å±¥æ­´ã®ã‚¹ãƒˆã‚¢ï¼ˆå¤šå¯¾1ãªã®ã§è‡ªå‹•ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã€cardIdã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
          if (!db.objectStoreNames.contains("reviews")) {
            const reviewStore = db.createObjectStore("reviews", { keyPath: "id", autoIncrement: true });
            reviewStore.createIndex("cardId", "cardId", { unique: false });
          } else {
            const reviewStore = tx.objectStore("reviews");
            if (!reviewStore.indexNames.contains("cardId")) {
              reviewStore.createIndex("cardId", "cardId", { unique: false });
            }
          }

          // ã‚«ãƒ¼ãƒ‰ã”ã¨ã®çµ±è¨ˆæƒ…å ±ï¼ˆå­¦ç¿’çŠ¶æ…‹ãªã©ï¼‰ã®ã‚¹ãƒˆã‚¢
          if (!db.objectStoreNames.contains("cardStats")) {
            db.createObjectStore("cardStats", { keyPath: "cardId" });
          }
        };

        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // ã‚«ãƒ¼ãƒ‰ç¾¤ã®ä¸€æ‹¬ä¿å­˜
    async function saveCards(cards) {
      const db = await openDB();
      const tx = db.transaction("cards", "readwrite");
      const store = tx.objectStore("cards");
      const promises = cards.map(card => {
        return new Promise((resolve, reject) => {
          const req = store.put(card);
          req.onsuccess = () => resolve();
          req.onerror = () => reject(req.error);
        });
      });
      await Promise.all(promises);
    }

    // å…¨ã‚«ãƒ¼ãƒ‰ã®èª­ã¿è¾¼ã¿
    async function loadCards() {
      const db = await openDB();
      const tx = db.transaction("cards", "readonly");
      const store = tx.objectStore("cards");
      return new Promise((resolve, reject) => {
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // ç‰¹å®šã‚«ãƒ¼ãƒ‰ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼å±¥æ­´èª­ã¿è¾¼ã¿
    async function loadReviewsByCardId(cardId) {
      const db = await openDB();
      const tx = db.transaction("reviews", "readonly");
      const store = tx.objectStore("reviews");
      const index = store.index("cardId");
      return new Promise((resolve, reject) => {
        const req = index.getAll(cardId);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    
    // å…¨ãƒ¬ãƒ“ãƒ¥ãƒ¼å±¥æ­´ã®èª­ã¿è¾¼ã¿ï¼ˆMCMCãªã©ã§ä½¿ç”¨ï¼‰
    async function loadAllReviews() {
      const db = await openDB();
      const tx = db.transaction("reviews", "readonly");
      const store = tx.objectStore("reviews");
      return new Promise((resolve, reject) => {
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®ä¿å­˜
    async function saveReviewToDB(review) {
      const db = await openDB();
      const tx = db.transaction("reviews", "readwrite");
      const store = tx.objectStore("reviews");
      return new Promise((resolve, reject) => {
        const req = store.add(review);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // çµ±è¨ˆæƒ…å ±ã®ä¿å­˜ï¼ˆstate, estimatedPãªã©ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼‰
    async function saveStatsToDB(stats) {
      const db = await openDB();
      const tx = db.transaction("cardStats", "readwrite");
      const store = tx.objectStore("cardStats");
      store.put(stats);
    }

    /* --- 4. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ© & MCMC ãƒ­ã‚¸ãƒƒã‚¯ (æ–°ãƒ¢ãƒ‡ãƒ«) --- */
    
    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: Sigmoid
    function sigmoid(x) {
      return 1.0 / (1.0 + Math.exp(-x));
    }
    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: Logit
    function logit(p) {
      // 0, 1ä»˜è¿‘ã®æ•°å€¤å®‰å®šåŒ–
      p = Math.max(0.0001, Math.min(0.9999, p));
      return Math.log(p / (1.0 - p));
    }

    /**
     * çµ±è¨ˆè¨ˆç®—ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯
     * logit(p_it) = Î²0 + Î²1*logit(p_hist) + Î²2*log(r(t)) + d_path
     */
    function calculateP(reviews, config, targetTime = Date.now(), cardPath = null) {
      // å±¥æ­´ãŒãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç¢ºç‡0.5
      if (!reviews || reviews.length === 0) return 0.5;

      const lastReview = reviews[reviews.length - 1];
      const lastReviewedAt = new Date(lastReview.reviewedAt).getTime();
      const t_sec = (targetTime - lastReviewedAt) / 1000;
      const t_days = t_sec / 86400.0;

      // 1. åŠ é‡å¹³å‡æ­£ç­”ç‡ p_hist ã®è¨ˆç®—
      // w_k = 1 / (k + Î»)
      // æ–°ã—ã„é †ã« k=1, 2, ...
      const reversed = [...reviews].reverse();
      let weightedScoreSum = 0;
      let weightedWeightSum = 0;
      const lambda = config.LAMBDA || 1.0;

      reversed.forEach((r, idx) => {
        const k = idx + 1;
        const weight = 1.0 / (k + lambda);
        weightedScoreSum += weight * (r.outcome === "correct" ? 1.0 : 0.0);
        weightedWeightSum += weight;
      });

      // å±¥æ­´æ­£ç­”ç‡
      const p_hist = weightedScoreSum / weightedWeightSum;
      const logit_p_hist = logit(p_hist);

      // 2. å¿˜å´ç‡ r(t) ã®è¨ˆç®—
      // r(t) = (1 + t / Ï„)^(-Î³)
      const tau = config.TAU || 1.0;
      const gamma = config.GAMMA || 1.0;
      // t_daysãŒè² ã«ãªã‚‹ï¼ˆæœªæ¥æ™‚åˆ»ï¼‰å ´åˆã¸ã®ã‚¬ãƒ¼ãƒ‰
      const safe_t = Math.max(0, t_days); 
      const r_t = Math.pow(1.0 + safe_t / tau, -gamma);
      const log_r_t = Math.log(r_t);

      // 3. Pathå›ºæœ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ d_path
      let d_path = 0.0;
      if (cardPath && config.PATH_INTERCEPTS && config.PATH_INTERCEPTS[cardPath] !== undefined) {
        d_path = config.PATH_INTERCEPTS[cardPath];
      }

      // 4. ç·šå½¢çµåˆ
      const beta0 = config.BETA_0 || 0.0;
      const beta1 = config.BETA_1 || 1.0;
      const beta2 = config.BETA_2 || 1.0;

      const logit_p = beta0 + beta1 * logit_p_hist + beta2 * log_r_t + d_path;

      // 5. ç¢ºç‡ã«æˆ»ã™
      return sigmoid(logit_p);
    }

    // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ã‚¯ãƒ©ã‚¹
    class Scheduler {
      constructor() {
        this.statsMap = new Map();
        this.cardsMap = new Map();
      }

      async init(cards) {
        this.cardsMap.clear();
        this.statsMap.clear();
        cards.forEach(c => this.cardsMap.set(c.id, c));

        const allReviews = await loadAllReviews();
        const reviewsByCard = {};
        allReviews.forEach(r => {
          if (!reviewsByCard[r.cardId]) reviewsByCard[r.cardId] = [];
          reviewsByCard[r.cardId].push(r);
        });

        for (const card of cards) {
          const cardReviews = reviewsByCard[card.id] || [];
          cardReviews.sort((a, b) => new Date(a.reviewedAt) - new Date(b.reviewedAt));
          
          const stats = new CardStats(card.id);
          this.updateStatsObject(stats, cardReviews); 
          this.statsMap.set(card.id, stats);
        }
      }

    //   updateStatsObject(stats, reviews) {
    //     if (reviews.length === 0) {
    //       stats.state = "new";
    //       stats.estimatedP = 0.5;
    //       stats.lastReviewedAt = null;
    //       stats.consecutiveHighP = 0;
    //       return;
    //     }

    //     const card = this.cardsMap.get(stats.cardId);
    //     const cardPath = card ? card.path : null;

    //     const p = calculateP(reviews, CONFIG, Date.now(), cardPath);
    //     stats.estimatedP = p;
    //     stats.lastReviewedAt = new Date(reviews[reviews.length - 1].reviewedAt).getTime();

    //     if (stats.state === "new") {
    //       stats.state = "learning";
    //       stats.consecutiveHighP = 0;
    //     }

    //     if (stats.state === "learning") {
    //       if (p >= CONFIG.MASTER_PROB_THRESHOLD) {
    //         stats.consecutiveHighP++;
    //       } else {
    //         stats.consecutiveHighP = 0;
    //       }
    //       if (stats.consecutiveHighP >= CONFIG.CONSECUTIVE_SUCCESS_REQUIRED) {
    //         stats.state = "mastered";
    //         stats.consecutiveHighP = 0;
    //       }
    //     } else if (stats.state === "mastered") {
    //       if (p <= CONFIG.LEARNING_PROB_THRESHOLD) {
    //         stats.state = "learning";
    //         stats.consecutiveHighP = 0;
    //       }
    //     }
    //   }

        updateStatsObject(stats, reviews, learningCount = 0) {
        // 1. æœªå­¦ç¿’ï¼ˆæ–°è¦ï¼‰ã‚«ãƒ¼ãƒ‰ã®å‡¦ç†
        if (reviews.length === 0) {
            stats.state = "new";
            stats.estimatedP = 0.5;
            stats.lastReviewedAt = null;
            return;
        }

        const card = this.cardsMap.get(stats.cardId);
        const cardPath = card ? card.path : null;

        // 2. ç¾åœ¨ã®æ­£ç­”ç‡ p ã‚’è¨ˆç®—
        const p = calculateP(reviews, CONFIG, Date.now(), cardPath);
        stats.estimatedP = p;
        stats.lastReviewedAt = new Date(reviews[reviews.length - 1].reviewedAt).getTime();

        // --- çŠ¶æ…‹é·ç§»ãƒ­ã‚¸ãƒƒã‚¯ ---

        // 3. new ã¯åˆå›å›ç­”å¾Œã«å¿…ãš learning ã¸
        if (stats.state === "new") {
            stats.state = "learning";
        }

        if (stats.state === "learning") {
            // 4. learning -> mastered: æ¨å®šæ­£ç­”ç‡ãŒ 0.9 (é–¾å€¤) ä»¥ä¸Š
            if (p >= CONFIG.MASTER_PROB_THRESHOLD) {
            stats.state = "mastered";
            }
        } else if (stats.state === "mastered") {
            // 5. mastered -> learning: æ­£ç­”ç‡ãŒ 0.8 (é–¾å€¤) æœªæº€ ã‹ã¤ learningæ ã«ç©ºããŒã‚ã‚‹
            // â€» learningCount ã®è€ƒæ…®ãŒä¸è¦ãªå ´åˆã¯ã€p ã®åˆ¤å®šã®ã¿ã«ã™ã‚‹
            const canReturnToLearning = learningCount < CONFIG.MAX_LEARNING_CARDS;
            
            if (p < CONFIG.LEARNING_PROB_THRESHOLD && canReturnToLearning) {
            stats.state = "learning";
            }
        }
        }

      async recordResult(cardId, outcome) {
        const review = {
          cardId,
          outcome,
          reviewedAt: new Date().toISOString()
        };
        await saveReviewToDB(review);
        
        const reviews = await loadReviewsByCardId(cardId);
        const stats = this.statsMap.get(cardId);
        this.updateStatsObject(stats, reviews);
        saveStatsToDB(stats);
      }

      selectNextCard() {
        const statsList = Array.from(this.statsMap.values());
        if (statsList.length === 0) return null;

        const newCards = statsList.filter(s => s.state === "new");
        const learningCards = statsList.filter(s => s.state === "learning");
        const masteredCards = statsList.filter(s => s.state === "mastered");

        if (Math.random() < CONFIG.EXPLORATION_RATE) {
          const pool = [...learningCards, ...masteredCards];
          if (pool.length > 0) return this.pickRandom(pool);
          if (newCards.length > 0) return this.pickRandom(newCards);
          return null;
        }

        if (learningCards.length > CONFIG.LEARNING_THRESHOLD) {
          const likelyWrong = learningCards.filter(s => this.isLikelyWrong(s));
          return likelyWrong.length > 0 ? this.pickRandom(likelyWrong) : this.pickRandom(learningCards);
        } else {
          const degradable = masteredCards.filter(s => s.estimatedP <= CONFIG.LEARNING_PROB_THRESHOLD);
          degradable.forEach(s => {
             s.state = "learning"; 
             masteredCards.splice(masteredCards.indexOf(s), 1);
             learningCards.push(s);
          });

          const likelyWrong = learningCards.filter(s => this.isLikelyWrong(s));

          if (likelyWrong.length < CONFIG.LIKELY_WRONG_LIMIT) {
            if (newCards.length > 0) return this.pickRandom(newCards);
          }

          if (likelyWrong.length > 0) return this.pickRandom(likelyWrong);
          if (learningCards.length > 0) return this.pickRandom(learningCards);
          if (masteredCards.length > 0) return this.pickRandom(masteredCards);
          if (newCards.length > 0) return this.pickRandom(newCards);
        }
        return null;
      }

      isLikelyWrong(stats) {
        return Math.random() > stats.estimatedP;
      }

      pickRandom(list) {
        const idx = Math.floor(Math.random() * list.length);
        return this.cardsMap.get(list[idx].cardId);
      }
      
      getStats(cardId) {
        return this.statsMap.get(cardId);
      }
    }

    /* --- MCMC Engine (ãƒãƒ«ã‚³ãƒ•é€£é–ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­æ³•) --- */
    class MCMCEngine {
      constructor() {
        this.reviewsByCard = {};
        this.cardPathMap = {};
        this.uniquePaths = new Set();
      }

      // æº–å‚™: ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰ã¨ãƒãƒƒãƒ”ãƒ³ã‚°ä½œæˆ
      async prepare() {
        // ã‚«ãƒ¼ãƒ‰æƒ…å ±ã®ãƒ­ãƒ¼ãƒ‰ï¼ˆPathæƒ…å ±ã®ãŸã‚ï¼‰
        const allCards = await loadCards();
        this.cardPathMap = {};
        this.uniquePaths.clear();
        allCards.forEach(c => {
          this.cardPathMap[c.id] = c.path;
          this.uniquePaths.add(c.path);
        });

        // ãƒ¬ãƒ“ãƒ¥ãƒ¼å±¥æ­´ã®ãƒ­ãƒ¼ãƒ‰
        const allReviews = await loadAllReviews();
        this.reviewsByCard = {};
        allReviews.forEach(r => {
          if (!this.reviewsByCard[r.cardId]) this.reviewsByCard[r.cardId] = [];
          this.reviewsByCard[r.cardId].push(r);
        });
        
        // ã‚½ãƒ¼ãƒˆ
        const lists = Object.values(this.reviewsByCard);
        for (let i = 0; i < lists.length; i++) {
          lists[i].sort((a, b) => new Date(a.reviewedAt) - new Date(b.reviewedAt));
          if (i % 50 === 0) await new Promise(r => setTimeout(r, 0));
        }
        return allReviews.length;
      }

      // å¯¾æ•°å°¤åº¦ + å¯¾æ•°äº‹å‰åˆ†å¸ƒ
      calculateLogPosterior(params) {
        let logLikelihood = 0;
        
        // 1. å¯¾æ•°å°¤åº¦
        for (const cardId in this.reviewsByCard) {
          const reviews = this.reviewsByCard[cardId];
          const path = this.cardPathMap[cardId];

          for (let i = 0; i < reviews.length; i++) {
            const currentReview = reviews[i];
            const history = reviews.slice(0, i); 
            
            // äºˆæ¸¬ç¢ºç‡
            const predictedP = calculateP(history, params, new Date(currentReview.reviewedAt).getTime(), path);
            
            // å°¤åº¦åŠ ç®—
            const prob = currentReview.outcome === "correct" ? predictedP : (1 - predictedP);
            const safeProb = Math.max(1e-9, Math.min(1 - 1e-9, prob));
            logLikelihood += Math.log(safeProb);
          }
        }

        // 2. å¯¾æ•°äº‹å‰åˆ†å¸ƒ (æ­£è¦åˆ†å¸ƒ)
        // log P(x) ~ -0.5 * (x - mu)^2 / sigma^2
        // Î²0, Î²1, Î²2, d_path ã«å¯¾ã—ã¦ N(0, 5^2) ã‚’ä»®å®š (sigma=5, variance=25)
        const variance = 25.0;
        let logPrior = 0;

        const priorParams = ['BETA_0', 'BETA_1', 'BETA_2'];
        for (const key of priorParams) {
          const val = params[key];
          logPrior += -0.5 * (val * val) / variance;
        }

        // d_path ã®äº‹å‰åˆ†å¸ƒ
        if (params.PATH_INTERCEPTS) {
          for (const pathKey in params.PATH_INTERCEPTS) {
            const val = params.PATH_INTERCEPTS[pathKey];
            logPrior += -0.5 * (val * val) / variance;
          }
        }

        // Ï„, Î³, Î» ã¯æ­£ã®å€¤ã§ã‚ã‚‹ã¹ãã ãŒã€å°¤åº¦è¨ˆç®—ã§ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã‘ã‚Œã°
        // å¼·ã„äº‹å‰åˆ†å¸ƒã¯ãŠã‹ãšã€å¢ƒç•Œãƒã‚§ãƒƒã‚¯ã®ã¿ææ¡ˆæ™‚ã«è¡Œã†æ–¹é‡ã¨ã™ã‚‹ã€‚

        return logLikelihood + logPrior;
      }

      // è¤‡æ•°ãƒã‚§ãƒ¼ãƒ³ã§ã®å®Ÿè¡Œ
      async runChains(numChains = 8, iterations = 10000, onProgress) {
        const chains = [];
        const burnIn = Math.floor(iterations * 0.4); // 40%ã‚’ãƒãƒ¼ãƒ³ã‚¤ãƒ³ã¨ã™ã‚‹

        // åˆæœŸåŒ–: å„ãƒã‚§ãƒ¼ãƒ³ã§å°‘ã—ç•°ãªã‚‹åˆæœŸå€¤ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
        for (let m = 0; m < numChains; m++) {
          const initParams = JSON.parse(JSON.stringify(CONFIG));
          // å°‘ã—æ•£ã‚‰ã™
          initParams.BETA_0 += (Math.random() - 0.5);
          initParams.TAU += (Math.random() - 0.5) * 0.2;
          // Path paramsåˆæœŸåŒ–ï¼ˆã‚‚ã—ç„¡ã‘ã‚Œã°ï¼‰
          if (!initParams.PATH_INTERCEPTS) initParams.PATH_INTERCEPTS = {};
          this.uniquePaths.forEach(p => {
             if (initParams.PATH_INTERCEPTS[p] === undefined) {
               initParams.PATH_INTERCEPTS[p] = 0.0;
             }
             // åˆæœŸå€¤ã‚’å°‘ã—æ•£ã‚‰ã™
             initParams.PATH_INTERCEPTS[p] += (Math.random() - 0.5) * 0.1;
          });
          
          chains.push({
            currentParams: initParams,
            currentL: this.calculateLogPosterior(initParams),
            samples: [] // { BETA_0: ..., ... }
          });
        }

        const proposalSigma = {
          BETA_0: 0.1, BETA_1: 0.1, BETA_2: 0.1,
          TAU: 0.2, GAMMA: 0.1, LAMBDA: 0.2,
          PATH_INTERCEPT: 0.2
        };

        const batchSize = 10;
        const totalSteps = numChains * iterations;
        let processedSteps = 0;

        for (let m = 0; m < numChains; m++) {
          const chain = chains[m];
          
          for (let i = 0; i < iterations; i++) {
            processedSteps++;
            if (i % batchSize === 0) {
              onProgress(processedSteps, totalSteps, chain.currentL);
              await new Promise(r => setTimeout(r, 0));
            }

            // --- Component-wise Metropolis-Hastings ---
            
            // Step 1: å…±é€šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ä¸€æ‹¬æ›´æ–° (ãƒ–ãƒ­ãƒƒã‚¯æ›´æ–°)
            // ï¼ˆã¾ãŸã¯å€‹åˆ¥ã«æ›´æ–°ã—ãŸã»ã†ãŒæ¡æŠç‡ã¯é«˜ã„ãŒã€å®Ÿè£…ç°¡ç•¥åŒ–ã®ãŸã‚ã“ã“ã§ã¯å°å¹…ã«ä¸€æ‹¬ï¼‰
            let newParams = JSON.parse(JSON.stringify(chain.currentParams));
            
            // ãƒ©ãƒ³ãƒ€ãƒ ã«1~2å€‹ã®å…±é€šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é¸ã‚“ã§å¤‰æ›´ã™ã‚‹
            const keys = ['BETA_0', 'BETA_1', 'BETA_2', 'TAU', 'GAMMA', 'LAMBDA'];
            const targetKey = keys[Math.floor(Math.random() * keys.length)];
            
            newParams[targetKey] += (Math.random() - 0.5) * proposalSigma[targetKey];

            // åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ (æ­£ã®å€¤ãªã©)
            if (newParams.TAU < 0.01) newParams.TAU = 0.01;
            if (newParams.GAMMA < 0.01) newParams.GAMMA = 0.01;
            if (newParams.LAMBDA < 0.01) newParams.LAMBDA = 0.01;

            let newL = this.calculateLogPosterior(newParams);
            if (Math.log(Math.random()) < (newL - chain.currentL)) {
              chain.currentParams = newParams;
              chain.currentL = newL;
            }

            // Step 2: Pathãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ›´æ–° (ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤ã®ãƒ‘ã‚¹ã‚’é¸ã‚“ã§æ›´æ–°)
            if (this.uniquePaths.size > 0) {
              const pathArray = Array.from(this.uniquePaths);
              const targetPath = pathArray[Math.floor(Math.random() * pathArray.length)];
              
              newParams = JSON.parse(JSON.stringify(chain.currentParams));
              newParams.PATH_INTERCEPTS[targetPath] += (Math.random() - 0.5) * proposalSigma.PATH_INTERCEPT;
              
              newL = this.calculateLogPosterior(newParams);
              if (Math.log(Math.random()) < (newL - chain.currentL)) {
                chain.currentParams = newParams;
                chain.currentL = newL;
              }
            }

            // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°è¨˜éŒ² (ãƒãƒ¼ãƒ³ã‚¤ãƒ³å¾Œ)
            if (i >= burnIn) {
              // Deep copyã—ã¦ä¿å­˜
              chain.samples.push(JSON.parse(JSON.stringify(chain.currentParams)));
            }
          }
        }

        // çµ±è¨ˆé‡ (Mean, Rhat) ã®è¨ˆç®—
        const stats = this.calculateStatistics(chains);
        
        // æœ€é©å€¤ã¨ã—ã¦ã€å…¨ãƒã‚§ãƒ¼ãƒ³ã®äº‹å¾Œå¹³å‡ã‚’æ¡ç”¨ã™ã‚‹ï¼ˆã‚ã‚‹ã„ã¯MAPï¼‰
        // ã“ã“ã§ã¯äº‹å¾Œå¹³å‡ã‚’æ¡ç”¨
        return { 
          bestParams: stats.means, 
          stats: stats.metrics,
          initialL: this.calculateLogPosterior(CONFIG) 
        };
      }

      // Gelman-Rubin Rhat è¨ˆç®—
      calculateStatistics(chains) {
        const paramKeys = ['BETA_0', 'BETA_1', 'BETA_2', 'TAU', 'GAMMA', 'LAMBDA'];
        const M = chains.length;
        const N = chains[0].samples.length;
        
        const metrics = {};
        const means = JSON.parse(JSON.stringify(chains[0].samples[N-1])); // é››å½¢
        // Pathãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚‚å«ã‚€ã‚ˆã†ã«åˆæœŸåŒ–
        if (!means.PATH_INTERCEPTS) means.PATH_INTERCEPTS = {};

        // å…±é€šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®é›†è¨ˆ
        paramKeys.forEach(key => {
          const { mean, rhat } = this.computeRhat(chains, s => s[key]);
          metrics[key] = { mean, rhat };
          means[key] = mean;
        });

        // Pathãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®é›†è¨ˆ
        // å…¨ãƒ‘ã‚¹ã«ã¤ã„ã¦è¨ˆç®—ã™ã‚‹ã¨é‡ã„ï¼†è¡¨ç¤ºã—ãã‚Œãªã„ã®ã§ã€è¨ˆç®—ã¯ã™ã‚‹ãŒRhatè¡¨ç¤ºã¯çœç•¥æ°—å‘³ã«ã™ã‚‹ã‹ã‚‚
        this.uniquePaths.forEach(path => {
          const { mean, rhat } = this.computeRhat(chains, s => s.PATH_INTERCEPTS[path]);
          means.PATH_INTERCEPTS[path] = mean;
          // å…¨éƒ¨ã¯è¿”ã•ãªã„ãŒã€ãƒ‡ãƒãƒƒã‚°çš„ã«ä¿æŒã—ãŸã‘ã‚Œã°ã“ã“ã§ metrics ã«å…¥ã‚Œã‚‹
        });

        return { metrics, means };
      }

      computeRhat(chains, valueExtractor) {
        const M = chains.length;
        const N = chains[0].samples.length;

        // å„ãƒã‚§ãƒ¼ãƒ³ã®å¹³å‡ã¨åˆ†æ•£
        const chainMeans = [];
        const chainVars = [];

        chains.forEach(c => {
          const values = c.samples.map(valueExtractor);
          const mean = values.reduce((a,b)=>a+b, 0) / N;
          const variance = values.reduce((a,b)=>a + Math.pow(b-mean, 2), 0) / (N-1);
          chainMeans.push(mean);
          chainVars.push(variance);
        });

        // å…¨ä½“å¹³å‡
        const grandMean = chainMeans.reduce((a,b)=>a+b, 0) / M;

        // ãƒã‚§ãƒ¼ãƒ³é–“åˆ†æ•£ B
        const B = (N / (M - 1)) * chainMeans.reduce((a,b)=>a + Math.pow(b-grandMean, 2), 0);

        // ãƒã‚§ãƒ¼ãƒ³å†…åˆ†æ•£ W
        const W = chainVars.reduce((a,b)=>a+b, 0) / M;

        // äº‹å¾Œåˆ†æ•£ã®æ¨å®š V_hat
        const V_hat = ((N - 1) / N) * W + (B / N); // é€šå¸¸ã¯ ((N-1)/N)*W + ((M+1)/(MN))*B ã ãŒç°¡æ˜“ç‰ˆ

        // Rhat
        const rhat = Math.sqrt(V_hat / W);
        
        return { mean: grandMean, rhat };
      }
    }


    /* --- 5. ãƒ“ãƒ¥ãƒ¼åˆ¶å¾¡ (UIãƒ­ã‚¸ãƒƒã‚¯) --- */
    const appEl = document.getElementById("app");
    const toolbarEl = document.getElementById("toolbar");

    // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®è¡¨ç¤ºåˆ‡æ›¿
    function setToolbarVisibility(visible) {
      toolbarEl.style.display = visible ? "flex" : "none";
    }

    // å­¦ç¿’ä¸­æ–­ãƒœã‚¿ãƒ³ã®ç”Ÿæˆ
    function createBackButton(onClick) {
      const container = document.createElement("div");
      container.className = "back-button-container";
      const btn = document.createElement("button");
      btn.className = "back-btn";
      btn.textContent = "â† ä¸­æ–­ã—ã¦æˆ»ã‚‹";
      btn.addEventListener("click", onClick);
      container.appendChild(btn);
      return container;
    }

    // ã‚«ãƒ¼ãƒ‰è¦ç´ ã®ç”Ÿæˆï¼ˆã‚¹ãƒ¯ã‚¤ãƒ—ã‚¤ãƒ™ãƒ³ãƒˆå«ã‚€ï¼‰
    function createCardView(card, stats, { onSwipe }) {
      const cardEl = document.createElement("div");
      cardEl.className = "card";

      // ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¡¨ç¤ºï¼ˆä¸Šéƒ¨ï¼‰
      const debugEl = document.createElement("div");
      debugEl.className = "card-stats-debug";
      debugEl.innerHTML = `
        State: <b>${stats.state}</b><br>
        Est. P: ${(stats.estimatedP * 100).toFixed(1)}%<br>
        Last: ${stats.lastReviewedAt ? new Date(stats.lastReviewedAt).toLocaleTimeString() : "Never"}
      `;
      cardEl.appendChild(debugEl);

      // å•é¡Œæ–‡
      const questionEl = document.createElement("div");
      questionEl.className = "question";
      questionEl.textContent = card.question;

      // è§£ç­”ï¼ˆåˆæœŸã¯éè¡¨ç¤ºï¼‰
      const answerEl = document.createElement("div");
      answerEl.className = "answer hidden";
      answerEl.textContent = card.answer;
      
      // è£œè¶³ãƒ¡ãƒ¢
      if (card.note) {
        const noteEl = document.createElement("div");
        noteEl.style.fontSize = "0.8rem";
        noteEl.style.color = "#888";
        noteEl.style.marginTop = "10px";
        noteEl.style.textAlign = "left";
        noteEl.textContent = card.note;
        answerEl.appendChild(noteEl);
      }
      
      // ã‚¬ã‚¤ãƒ‰ãƒ†ã‚­ã‚¹ãƒˆ
      const guideEl = document.createElement("div");
      guideEl.style.marginTop = "auto";
      guideEl.style.paddingTop = "20px";
      guideEl.style.fontSize = "0.8rem";
      guideEl.style.color = "#ccc";
      guideEl.style.textAlign = "center";
      guideEl.textContent = "ã‚¿ãƒƒãƒ—ã§ç­”ãˆã‚’è¡¨ç¤º / å·¦å³ã‚¹ãƒ¯ã‚¤ãƒ—ã§å›ç­”";
      answerEl.appendChild(guideEl);

      cardEl.append(questionEl, answerEl);
      
      // ã‚¿ãƒƒãƒ—ã§æ­£è§£è¡¨ç¤ºãƒˆã‚°ãƒ«
      cardEl.addEventListener("click", () => answerEl.classList.toggle("hidden"));

      // ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œã®å®Ÿè£…
      let startX = null;
      let startY = null;
      cardEl.addEventListener("pointerdown", (e) => {
        startX = e.clientX;
        startY = e.clientY;
        cardEl.setPointerCapture(e.pointerId);
      });
      cardEl.addEventListener("pointerup", (e) => {
        if (startX === null) return;
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        const threshold = 60; // ã‚¹ãƒ¯ã‚¤ãƒ—åˆ¤å®šé–¾å€¤
        
        // æ¨ªæ–¹å‘ã¸ã®ç§»å‹•ãŒå¤§ããã€ç¸¦æ–¹å‘ã¸ã®ç§»å‹•ãŒå°ã•ã„å ´åˆã®ã¿ã‚¹ãƒ¯ã‚¤ãƒ—ã¨åˆ¤å®š
        if (Math.abs(deltaX) > threshold && Math.abs(deltaY) < 60) {
          if (deltaX > 0) onSwipe("correct"); // å³ã‚¹ãƒ¯ã‚¤ãƒ—: æ­£è§£
          else onSwipe("incorrect");          // å·¦ã‚¹ãƒ¯ã‚¤ãƒ—: ä¸æ­£è§£
        }
        startX = null;
        startY = null;
      });
      return cardEl;
    }

    /* --- Path Browser & List View (ãƒ•ã‚©ãƒ«ãƒ€éšå±¤è¡¨ç¤º) --- */
    function createPathBrowser(tree, handlers) {
      const container = document.createElement("div");
      container.className = "path-browser";

      // å†å¸°çš„ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼ã‚’æç”»
      function renderNode(node, depth = 0) {
        const wrapper = document.createElement("div");
        for (const key of Object.keys(node)) {
          if (key === "__cards__") continue; // å†…éƒ¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã‚¹ã‚­ãƒƒãƒ—
          const row = document.createElement("div");
          row.className = "folder-row";
          
          const infoDiv = document.createElement("div");
          infoDiv.className = "folder-info";
          infoDiv.textContent = key;
          infoDiv.style.paddingLeft = `${(depth * 20) + 10}px`;
          
          // ãã®ãƒ•ã‚©ãƒ«ãƒ€ä»¥ä¸‹ã®å…¨ã‚«ãƒ¼ãƒ‰ã‚’åé›†ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆ
          const childCards = collectCards(node[key]);
          const countSpan = document.createElement("span");
          countSpan.style.float = "right";
          countSpan.style.marginRight = "5px";
          countSpan.style.color = "#999";
          countSpan.style.fontSize = "0.9em";
          countSpan.textContent = `${childCards.length}å•`;
          infoDiv.appendChild(countSpan);
          
          // ãƒ•ã‚©ãƒ«ãƒ€ã‚¯ãƒªãƒƒã‚¯ã§å­¦ç¿’é–‹å§‹
          infoDiv.addEventListener("click", () => {
            if (childCards.length === 0) return;
            handlers.onPlay(childCards);
          });
          
          // 3ç‚¹ãƒªãƒ¼ãƒ€ãƒ¼ï¼ˆã‚±ãƒãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼‰ã®å®Ÿè£…
          const kebabContainer = document.createElement("div");
          kebabContainer.className = "kebab-container";
          const kebabBtn = document.createElement("div");
          kebabBtn.className = "kebab-btn";
          kebabBtn.textContent = "ï¸™";
          
          const menuPopup = document.createElement("div");
          menuPopup.className = "menu-popup";
          
          // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®1: å­¦ç¿’é–‹å§‹
          const playItem = document.createElement("div");
          playItem.className = "menu-item";
          playItem.textContent = "å­¦ç¿’é–‹å§‹";
          playItem.addEventListener("click", (e) => {
            e.stopPropagation();
            handlers.onPlay(childCards);
            closeAllMenus();
          });
          
          // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®2: å•é¡Œä¸€è¦§
          const listItem = document.createElement("div");
          listItem.className = "menu-item";
          listItem.textContent = "å•é¡Œä¸€è¦§";
          listItem.addEventListener("click", (e) => {
            e.stopPropagation();
            handlers.onList(childCards, key);
            closeAllMenus();
          });
          
          menuPopup.append(playItem, listItem);
          kebabContainer.append(kebabBtn, menuPopup);
          
          kebabBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            const isOpen = menuPopup.classList.contains("show");
            closeAllMenus();
            if (!isOpen) menuPopup.classList.add("show");
          });
          
          row.append(infoDiv, kebabContainer);
          wrapper.appendChild(row);
          wrapper.appendChild(renderNode(node[key], depth + 1));
        }
        return wrapper;
      }
      container.appendChild(renderNode(tree));
      return container;
    }

    // é–‹ã„ã¦ã„ã‚‹ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’å…¨ã¦é–‰ã˜ã‚‹
    function closeAllMenus() {
      document.querySelectorAll(".menu-popup.show").forEach(el => el.classList.remove("show"));
    }
    document.addEventListener("click", () => closeAllMenus());

    /* --- ãƒ‡ãƒ¼ã‚¿å‡¦ç†é–¢æ•°ç¾¤ --- */
    
    // ãƒ•ãƒ©ãƒƒãƒˆãªã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆã‚’ãƒ•ã‚©ãƒ«ãƒ€éšå±¤æ§‹é€ ï¼ˆãƒ„ãƒªãƒ¼ï¼‰ã«å¤‰æ›
    function buildPathTree(cards) {
      const root = {};
      for (const card of cards) {
        const parts = card.path.split("/");
        let node = root;
        for (const part of parts) {
          if (!node[part]) node[part] = {};
          node = node[part];
        }
        if (!node.__cards__) node.__cards__ = [];
        node.__cards__.push(card);
      }
      return root;
    }

    // ãƒ„ãƒªãƒ¼ãƒãƒ¼ãƒ‰ä»¥ä¸‹ã®å…¨ã‚«ãƒ¼ãƒ‰ã‚’å†å¸°çš„ã«åé›†
    function collectCards(node) {
      let result = [];
      if (node.__cards__) result = result.concat(node.__cards__);
      for (const key of Object.keys(node)) {
        if (key !== "__cards__") result = result.concat(collectCards(node[key]));
      }
      return result;
    }

    // Excelãƒ•ã‚¡ã‚¤ãƒ«(XLSX)ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†
    async function importXLSX(file, path) {
      const data = await file.arrayBuffer();
      const workbook = XLSX.read(data);
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      const dataRows = rows.length > 1 ? rows.slice(1) : []; // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
      
      const cards = dataRows
        .filter(row => row.length > 0 && row[0]) // ç©ºè¡Œé™¤å¤–
        .map((row, index) => {
          const question = row[0] ? String(row[0]) : "";
          const answer = row[1] ? String(row[1]) : "";
          const note = row[2] ? String(row[2]) : "";
          // IDã¯ãƒ‘ã‚¹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€UUIDã‚’çµ„ã¿åˆã‚ã›ã¦ä¸€æ„æ€§ã‚’ç¢ºä¿
          return new Card({
            id: `${path}-${index}-${crypto.randomUUID()}`,
            path,
            question,
            answer,
            note
          });
        });
      await saveCards(cards);
      return cards;
    }

    /* --- ç”»é¢é·ç§»é–¢æ•° --- */
    let firstLaunch = false;

    // ãƒ•ã‚©ãƒ«ãƒ€é¸æŠï¼ˆãƒˆãƒƒãƒ—ï¼‰ç”»é¢ã®è¡¨ç¤º
    async function showPathSelection() {
      setToolbarVisibility(!firstLaunch);
      firstLaunch = false;
      const cards = await loadCards();
      appEl.innerHTML = "";

      if (cards.length === 0) {
        const msg = document.createElement("div");
        msg.textContent = "å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚å³ä¸Šã®ãƒœã‚¿ãƒ³ã‹ã‚‰Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚";
        msg.style.padding = "40px 20px";
        msg.style.textAlign = "center";
        appEl.appendChild(msg);
        return;
      }

      const tree = buildPathTree(cards);
      const browser = createPathBrowser(tree, {
        onPlay: (selectedCards) => startSmartQuiz(selectedCards),
        onList: (selectedCards, folderName) => showCardList(selectedCards, folderName)
      });
      appEl.appendChild(browser);
    }

    // å•é¡Œä¸€è¦§ç”»é¢ã®è¡¨ç¤º
    function showCardList(cards, title) {
      setToolbarVisibility(false);
      appEl.innerHTML = "";
      appEl.appendChild(createBackButton(() => showPathSelection()));

      const container = document.createElement("div");
      container.className = "card-list-view";
      const header = document.createElement("div");
      header.className = "list-header";
      header.textContent = `${title} (${cards.length}å•)`;
      container.appendChild(header);

      cards.forEach((card, i) => {
        const item = document.createElement("div");
        item.className = "list-item";
        const qDiv = document.createElement("div");
        qDiv.className = "list-q";
        qDiv.textContent = `Q${i+1}. ${card.question}`;
        const aDiv = document.createElement("div");
        aDiv.className = "list-a";
        aDiv.textContent = `A. ${card.answer}`;
        item.appendChild(qDiv);
        item.appendChild(aDiv);
        if (card.note) {
          const nDiv = document.createElement("div");
          nDiv.className = "list-note";
          nDiv.textContent = `Memo: ${card.note}`;
          item.appendChild(nDiv);
        }
        container.appendChild(item);
      });
      appEl.appendChild(container);
    }

    // ã‚¯ã‚¤ã‚ºé–‹å§‹ï¼ˆå­¦ç¿’ãƒ«ãƒ¼ãƒ—ï¼‰
    async function startSmartQuiz(cards) {
      if (!cards || cards.length === 0) return;
      
      setToolbarVisibility(false);
      appEl.innerHTML = "<div style='padding:40px; text-align:center;'>å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™ä¸­...</div>";

      const scheduler = new Scheduler();
      await scheduler.init(cards);

      // å‡ºé¡Œãƒ«ãƒ¼ãƒ—é–¢æ•°
      function nextLoop() {
        const nextCard = scheduler.selectNextCard();
        
        if (!nextCard) {
          alert("å‡ºé¡Œå¯èƒ½ãªã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
          showPathSelection();
          return;
        }

        const stats = scheduler.getStats(nextCard.id);
        
        appEl.innerHTML = "";
        appEl.appendChild(createBackButton(() => showPathSelection()));
        
        const cardView = createCardView(nextCard, stats, {
          onSwipe: async (outcome) => {
            // å›ç­”å¾Œã®å‡¦ç†
            appEl.innerHTML = "<div style='display:flex;height:100%;align-items:center;justify-content:center;font-weight:bold;color:#888;'>Saving...</div>";
            await scheduler.recordResult(nextCard.id, outcome);
            nextLoop(); // å†å¸°çš„ã«æ¬¡ã¸
          }
        });
        
        appEl.appendChild(cardView);
      }

      nextLoop();
    }

    /* --- Config UI Handler (è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã®åˆ¶å¾¡) --- */
    const configBtn = document.getElementById("configBtn");
    const configModal = document.getElementById("configModal");
    const configSave = document.getElementById("configSave");
    const configCancel = document.getElementById("configCancel");
    
    // ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡
    const cfgLearningThreshold = document.getElementById("cfgLearningThreshold");
    const cfgLikelyWrongLimit = document.getElementById("cfgLikelyWrongLimit");
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    const cfgBeta0 = document.getElementById("cfgBeta0");
    const cfgTau = document.getElementById("cfgTau");

    // è¨­å®šãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚: ç¾åœ¨ã®å€¤ã‚’ãƒ•ã‚©ãƒ¼ãƒ ã«åæ˜ ã—ã¦ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
    configBtn.addEventListener("click", () => {
      cfgLearningThreshold.value = CONFIG.LEARNING_THRESHOLD;
      cfgLikelyWrongLimit.value = CONFIG.LIKELY_WRONG_LIMIT;
      
      cfgBeta0.value = CONFIG.BETA_0;
      cfgTau.value = CONFIG.TAU;
      
      configModal.classList.remove("hidden");
    });

    configCancel.addEventListener("click", () => {
      configModal.classList.add("hidden");
    });

    // ä¿å­˜ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚: å…¥åŠ›å€¤ã‚’ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦ä¿å­˜
    configSave.addEventListener("click", () => {
      const lt = parseInt(cfgLearningThreshold.value, 10);
      const lwl = parseInt(cfgLikelyWrongLimit.value, 10);
      
      const b0 = parseFloat(cfgBeta0.value);
      const tau = parseFloat(cfgTau.value);

      if (lt > 0) CONFIG.LEARNING_THRESHOLD = lt;
      if (!isNaN(lwl) && lwl >= 0) CONFIG.LIKELY_WRONG_LIMIT = lwl;
      
      if (!isNaN(b0)) CONFIG.BETA_0 = b0;
      if (tau > 0) CONFIG.TAU = tau;

      saveConfig();
      alert("è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚");
      configModal.classList.add("hidden");
    });

    /* --- MCMC UI Handler (æœ€é©åŒ–ãƒ¢ãƒ¼ãƒ€ãƒ«ã®åˆ¶å¾¡) --- */
    const mcmcBtn = document.getElementById("mcmcBtn");
    const mcmcModal = document.getElementById("mcmcModal");
    const mcmcProgress = document.getElementById("mcmcProgress");
    const mcmcStatus = document.getElementById("mcmcStatus");
    const mcmcResults = document.getElementById("mcmcResults");
    const mcmcActions = document.getElementById("mcmcActions");
    const mcmcApply = document.getElementById("mcmcApply");
    const mcmcCancel = document.getElementById("mcmcCancel");
    const mcmcErrorActions = document.getElementById("mcmcErrorActions");
    const mcmcErrorClose = document.getElementById("mcmcErrorClose");

    let proposedConfig = null;

    // MCMCãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚: è¨ˆç®—é–‹å§‹
    mcmcBtn.addEventListener("click", async () => {
      // åˆæœŸåŒ–
      mcmcModal.classList.remove("hidden");
      mcmcStatus.textContent = "å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆä¸­...";
      mcmcResults.innerHTML = "";
      mcmcActions.style.display = "none";
      mcmcErrorActions.style.display = "none";
      mcmcProgress.style.width = "0%";
      mcmcStatus.style.color = "inherit";

      try {
        await new Promise(r => setTimeout(r, 100)); // UIæç”»å¾…ã¡

        const engine = new MCMCEngine();
        const count = await engine.prepare();
        
        const allReviews = await loadAllReviews();
        if (allReviews.length < 10) {
          mcmcStatus.textContent = "å±¥æ­´ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã™ãã¾ã™ï¼ˆ10ä»¶ä»¥ä¸Šå¿…è¦ï¼‰";
          mcmcErrorActions.style.display = "flex";
          return;
        }

        mcmcStatus.textContent = "æœ€é©åŒ–å®Ÿè¡Œä¸­ (2 Chains, 500 iter)...";
        
        // MCMCå®Ÿè¡Œ: 2 Chains, 500 Iterations
        const result = await engine.runChains(8, 10000, (step, total, currentL) => {
          const pct = Math.round((step / total) * 100);
          mcmcProgress.style.width = `${pct}%`;
          mcmcStatus.textContent = `Processing step ${step}/${total} (current log-posterior: ${currentL.toFixed(2)})`;
        });

        // çµæœè¡¨ç¤º
        mcmcProgress.style.width = "100%";
        mcmcStatus.textContent = "å®Œäº†ã—ã¾ã—ãŸã€‚";
        
        proposedConfig = result.bestParams;
        
        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰åŒ–ã®è¡¨ç¤ºç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
        function renderRow(label, key, fixed = 2) {
          const oldV = CONFIG[key];
          const stat = result.stats[key];
          const newV = stat.mean;
          const rhat = stat.rhat;
          
          const changed = Math.abs(oldV - newV) > 0.01 ? "changed" : "";
          const rhatClass = rhat > 1.1 ? "rhat-bad" : "";
          
          return `
            <div class="param-row">
              <span class="param-name">${label}</span>
              <span class="param-val ${changed}">${oldV.toFixed(fixed)} â†’ ${newV.toFixed(fixed)}</span>
              <span class="param-rhat ${rhatClass}">RÌ‚:${rhat.toFixed(2)}</span>
            </div>
          `;
        }

        let html = `
          <div style="margin-bottom:10px; font-size:0.9rem;">
             â€» RÌ‚ (R-hat) ãŒ1.1ä»¥ä¸‹ãªã‚‰åæŸè‰¯å¥½ã§ã™ã€‚<br>
             Pathå›ºæœ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚‚å†…éƒ¨ã§æ¨å®šã•ã‚Œã¾ã—ãŸã€‚
          </div>
          ${renderRow("Î²0 (Base)", "BETA_0")}
          ${renderRow("Î²1 (Hist)", "BETA_1")}
          ${renderRow("Î²2 (Time)", "BETA_2")}
          ${renderRow("Ï„ (Tau)", "TAU", 1)}
          ${renderRow("Î³ (Gamma)", "GAMMA")}
          ${renderRow("Î» (Lambda)", "LAMBDA")}
        `;

        mcmcResults.innerHTML = html;
        mcmcActions.style.display = "flex";

      } catch (err) {
        console.error(err);
        mcmcStatus.innerHTML = `<div class="error-msg">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:<br>${err.message}</div>`;
        mcmcErrorActions.style.display = "flex";
      }
    });

    mcmcCancel.addEventListener("click", () => {
      mcmcModal.classList.add("hidden");
    });

    mcmcErrorClose.addEventListener("click", () => {
      mcmcModal.classList.add("hidden");
    });

    mcmcApply.addEventListener("click", () => {
      if (proposedConfig) {
        // è¨­å®šã‚’æ›´æ–°ã—ã¦ä¿å­˜
        CONFIG = { ...CONFIG, ...proposedConfig };
        saveConfig();
        alert("è¨­å®šã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚");
        mcmcModal.classList.add("hidden");
        // ç”»é¢ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦åæ˜ 
        showPathSelection();
      }
    });

    /* --- ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š (ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ãªã©) --- */
    const tsvInput = document.getElementById("tsvInput");
    tsvInput.addEventListener("change", async e => {
      const file = e.target.files[0];
      if (!file) return;
      const path = prompt("ã“ã®å•é¡Œç¾¤ã®ãƒ•ã‚©ãƒ«ãƒ€åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: è‹±èª/è‹±å˜èª/Part1ï¼‰");
      if (!path) { tsvInput.value = ""; return; }
      try {
        await importXLSX(file, path);
        tsvInput.value = "";
        showPathSelection();
      } catch (err) {
        console.error(err);
        alert("èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ");
      }
    });

    // åˆå›èµ·å‹•
    showPathSelection();

  </script>
</body>
</html>