<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>暗記アプリ（統合モデル完全版）</title>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; overscroll-behavior: none; touch-action: none; }
    body { overflow: hidden; font-family: system-ui, sans-serif; background: #f5f5f5; }
    #app { display: flex; justify-content: center; align-items: flex-start; height: 100%; position: relative; }
    .card { background: white; width: 90%; max-width: 420px; margin-top: 10vh; padding: 24px; border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.15); }
    .question { font-size: 1.4rem; font-weight: bold; margin-bottom: 20px; }
    .answer { margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px; color: #444; }
    .hidden { display: none; }
    .path-browser { width: 100%; padding: 20px; box-sizing: border-box; }
    .folder { background: white; padding: 12px; margin: 6px 0; border-radius: 8px; cursor: pointer; }
    .topbar { position: fixed; top: 10px; right: 10px; z-index: 1000; background: white; padding: 6px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
  </style>
</head>
<body>
  <div class="topbar"><input type="file" id="fileInput" accept=".xlsx,.xls"></div>
  <main id="app"></main>

<script>
/* =====================
   Data Models
===================== */
class Card {
  constructor({id, path, question, answer}) {
    this.id = id
    this.path = path
    this.question = question
    this.answer = answer
  }
}

/* =====================
   IndexedDB
===================== */
const DB_NAME = "bayesFlash"
const DB_VERSION = 3

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION)
    req.onupgradeneeded = e => {
      const db = e.target.result
      if (!db.objectStoreNames.contains("cards")) db.createObjectStore("cards", {keyPath: "id"})
      if (!db.objectStoreNames.contains("reviews")) db.createObjectStore("reviews", {keyPath: "id", autoIncrement: true})
      if (!db.objectStoreNames.contains("stats")) db.createObjectStore("stats", {keyPath: "cardId"})
    }
    req.onsuccess = () => resolve(req.result)
    req.onerror = () => reject(req.error)
  })
}

async function storePut(name, obj) {
  const db = await openDB()
  const tx = db.transaction(name, "readwrite")
  tx.objectStore(name).put(obj)
}

async function storeGetAll(name) {
  const db = await openDB()
  return new Promise(res => {
    const tx = db.transaction(name, "readonly")
    const req = tx.objectStore(name).getAll()
    req.onsuccess = () => res(req.result)
  })
}

async function storeGet(name, key) {
  const db = await openDB()
  return new Promise(res => {
    const tx = db.transaction(name, "readonly")
    const req = tx.objectStore(name).get(key)
    req.onsuccess = () => res(req.result)
  })
}

/* =====================
   Import XLSX
===================== */
async function importXLSX(file, path) {
  const data = await file.arrayBuffer()
  const wb = XLSX.read(data)
  const sheet = wb.Sheets[wb.SheetNames[0]]
  const rows = XLSX.utils.sheet_to_json(sheet, {header:1}).slice(1)
  const cards = rows.filter(r => r[0]).map((r,i)=>new Card({
    id: `${path}-${i}-${crypto.randomUUID()}`,
    path,
    question: String(r[0]),
    answer: String(r[1] ?? "")
  }))
  for (const c of cards) await storePut("cards", c)
  return cards
}

/* =====================
   Path Tree
===================== */
function buildTree(cards) {
  const root = {}
  for (const c of cards) {
    let node = root
    for (const p of c.path.split("/")) {
      node[p] = node[p] || {}
      node = node[p]
    }
    node.__cards__ = node.__cards__ || []
    node.__cards__.push(c)
  }
  return root
}

function collect(node) {
  let r = node.__cards__ ? [...node.__cards__] : []
  for (const k in node) if (k !== "__cards__") r = r.concat(collect(node[k]))
  return r
}

/* =====================
   Bayesian Estimation
===================== */
function estimateP(cardId, history) {
  const alpha = 1, beta = 1
  if (!history || history.length === 0) return 0.5
  let wsum = 0, vsum = 0
  history.slice().reverse().forEach((h, i) => {
    const w = 1 / (i + 2)
    wsum += w
    vsum += w * (h.correct ? 1 : 0)
  })
  const mean = (vsum + alpha) / (wsum + alpha + beta)
  const t = (Date.now() - new Date(history.at(-1).time)) / (1000*60*60*24)
  const retention = Math.pow(1 + t / 9, -1)
  return Math.max(0.01, Math.min(0.99, mean * retention))
}

/* =====================
   Scheduler
===================== */
async function chooseNext(cards) {
  const stats = await storeGetAll("stats")
  const map = Object.fromEntries(stats.map(s=>[s.cardId, s]))
  const scored = cards.map(c => {
    const h = map[c.id]?.history || []
    return { card: c, p: estimateP(c.id, h) }
  })
  scored.sort((a,b)=>a.p-b.p)
  return scored[0].card
}

/* =====================
   UI
===================== */
const app = document.getElementById("app")

function renderBrowser(cards) {
  app.innerHTML = ""
  const tree = buildTree(cards)
  const wrap = document.createElement("div")
  wrap.className = "path-browser"
  function render(node) {
    for (const k in node) if (k !== "__cards__") {
      const div = document.createElement("div")
      div.className = "folder"
      const sub = collect(node[k])
      div.textContent = `${k} (${sub.length})`
      div.onclick = ()=>startQuiz(sub)
      wrap.appendChild(div)
      render(node[k])
    }
  }
  render(tree)
  app.appendChild(wrap)
}

function renderCard(card) {
  app.innerHTML = ""
  const el = document.createElement("div")
  el.className = "card"
  const q = document.createElement("div")
  q.className = "question"
  q.textContent = card.question
  const a = document.createElement("div")
  a.className = "answer hidden"
  a.textContent = card.answer
  el.append(q,a)
  el.onclick = ()=>a.classList.toggle("hidden")
  let startX=null
  el.onpointerdown = e=>startX=e.clientX
  el.onpointerup = async e=>{
    if(startX===null)return
    const dx=e.clientX-startX
    if(Math.abs(dx)>80){
      const correct = dx<0
      await record(card.id, correct)
      const next = await chooseNext(currentCards)
      renderCard(next)
    }
    startX=null
  }
  app.appendChild(el)
}

/* =====================
   Review Recording
===================== */
async function record(cardId, correct) {
  await storePut("reviews", {cardId, correct, time: Date.now()})
  const stat = await storeGet("stats", cardId) || {cardId, history: []}
  stat.history.push({correct, time: Date.now()})
  await storePut("stats", stat)
}

/* =====================
   Main Flow
===================== */
let currentCards = []

async function startQuiz(cards) {
  currentCards = cards
  const c = await chooseNext(cards)
  renderCard(c)
}

async function init() {
  const cards = await storeGetAll("cards")
  if (cards.length) renderBrowser(cards)
}

fileInput.onchange = async e => {
  const file = e.target.files[0]
  if (!file) return
  const path = prompt("フォルダ名")
  if (!path) return
  await importXLSX(file, path)
  init()
}

init()
</script>
</body>
</html>
